<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>redis常见知识点</title>
    <link href="/2025/10/05/redis%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2025/10/05/redis%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="一、redis优于memcache的地方"><a href="#一、redis优于memcache的地方" class="headerlink" title="一、redis优于memcache的地方"></a>一、redis优于memcache的地方</h1><h2 id="1、redis支持多种数据结构："><a href="#1、redis支持多种数据结构：" class="headerlink" title="1、redis支持多种数据结构："></a>1、redis支持多种数据结构：</h2><p> 1）<strong>String</strong>: 主要用于缓存对象，计数，分布式锁</p><p>  2）<strong>哈希表</strong>：也是主要用于缓存对象，但还可以缓存购物车</p><p> 3）<strong>链表</strong>：主要缓存消息队列</p><p> 4）<strong>集合</strong>：适用于需要交并差运算的场景，比如点赞，共同关注，抽奖活动</p><p>  5）<strong>有序集合</strong>：主要用于排行榜，电话，姓名排序等</p><h2 id="2、redis支持数据持久化"><a href="#2、redis支持数据持久化" class="headerlink" title="2、redis支持数据持久化"></a>2、redis支持数据持久化</h2><h2 id="3、redis支持原生集群模式"><a href="#3、redis支持原生集群模式" class="headerlink" title="3、redis支持原生集群模式"></a>3、redis支持原生集群模式</h2><h2 id="4、redis支持发布订阅模型，lua脚本、事务等功能，而memcache不支持。"><a href="#4、redis支持发布订阅模型，lua脚本、事务等功能，而memcache不支持。" class="headerlink" title="4、redis支持发布订阅模型，lua脚本、事务等功能，而memcache不支持。"></a>4、redis支持发布订阅模型，lua脚本、事务等功能，而memcache不支持。</h2><p>  但这些数据结构都还只是表象，redis底层还有对于这些数据结构实现的数据结构。</p><p>  1）String底层使用<strong>int</strong>和<strong>SDS</strong>（动态字符串)实现,int类型的len存放字符串的长度。</p><p>  2）hash类型底层使用<strong>压缩列表</strong>或<strong>哈希表</strong>实现。</p><p>  3）List类型使用<strong>压缩列表</strong>或<strong>双向链表</strong>实现。</p><p>  4）集合Set类型使用<strong>整数集合</strong>或<strong>哈希表</strong>实现。</p><p>  5）有序集合ZSet使用<strong>哈希表</strong>或<strong>跳表</strong>实现。</p><h1 id="二、Redis单线程"><a href="#二、Redis单线程" class="headerlink" title="二、Redis单线程"></a>二、Redis单线程</h1><h2 id="1、定义："><a href="#1、定义：" class="headerlink" title="1、定义："></a>1、定义：</h2><p>指【接收客户端请求-》解析请求-》进行数据读写-》发送数据给客户端】这个过程是由一个线程（主线程）来完成的。</p><p>但这并不意味着redis程序是单线程的。</p><p>redis还有后台线程。</p><p>redis在2.6之后，启动两个后台线程，分别处理关闭文件，aof刷盘。</p><p>4.0之后，又新增了一个后台线程，用来异步释放redis内存，叫lazyfree线程。</p><h2 id="2、结构图"><a href="#2、结构图" class="headerlink" title="2、结构图"></a>2、结构图</h2><h2 id="3、为什么单线程依然很快？"><a href="#3、为什么单线程依然很快？" class="headerlink" title="3、为什么单线程依然很快？"></a>3、为什么单线程依然很快？</h2><p>1)大部分操作都在内存中完成，瓶颈一般是机器内存或带宽，并非cpu，既然cpu不是瓶颈，自然采用单线程。</p><p>2）避免多线程竞争</p><p>3）redis采用io多路复用</p><h2 id="4、redis在6-0后引入了多个线程来处理io请求，"><a href="#4、redis在6-0后引入了多个线程来处理io请求，" class="headerlink" title="4、redis在6.0后引入了多个线程来处理io请求，"></a>4、redis在6.0后引入了多个线程来处理io请求，</h2><p>因为随着网络硬件的性能提升，redis性能瓶颈有时出现在网络io处理上。</p><p>但是对于命令的执行依然是单线程。</p><h1 id="三、AOF部分："><a href="#三、AOF部分：" class="headerlink" title="三、AOF部分："></a>三、AOF部分：</h1><h2 id="1、redis三种aof数据写入磁盘策略：always-everysec-no"><a href="#1、redis三种aof数据写入磁盘策略：always-everysec-no" class="headerlink" title="1、redis三种aof数据写入磁盘策略：always, everysec, no"></a>1、redis三种aof数据写入磁盘策略：always, everysec, no</h2><h2 id="2、aof太大超过阈值会触发重写机制"><a href="#2、aof太大超过阈值会触发重写机制" class="headerlink" title="2、aof太大超过阈值会触发重写机制"></a>2、aof太大超过阈值会触发重写机制</h2><p>1)使用后台<strong>子进程</strong>bgrewriteaof来完成，因此主线程可以在这时继续处理命令。</p><p>   子进程与父进程共享内存数据，子进程会读取数据库中的所有数据，并逐一将键值对转化为一条条命令，所以可以很方便的根据内存中的键值对来进行aof文件压缩。</p><h2 id="3、进行aof重写时父进程继续执行命令，会导致父子进程的内存数据不一致"><a href="#3、进行aof重写时父进程继续执行命令，会导致父子进程的内存数据不一致" class="headerlink" title="3、进行aof重写时父进程继续执行命令，会导致父子进程的内存数据不一致"></a>3、进行aof重写时父进程继续执行命令，会导致父子进程的内存数据不一致</h2><p>为解决这个问题，引入了aof重写缓冲区。在子进程完成aof重写后，会告诉主进程，让它调用一个函数，将aof重写缓冲区的所有内容追加到aof文件中去。</p><h1 id="四、RDB部分"><a href="#四、RDB部分" class="headerlink" title="四、RDB部分"></a>四、RDB部分</h1><h2 id="1、因为aof恢复数据是将日志重新执行一遍，所以比rdb快照式的恢复数据要慢一些。"><a href="#1、因为aof恢复数据是将日志重新执行一遍，所以比rdb快照式的恢复数据要慢一些。" class="headerlink" title="1、因为aof恢复数据是将日志重新执行一遍，所以比rdb快照式的恢复数据要慢一些。"></a>1、因为aof恢复数据是将日志重新执行一遍，所以比rdb快照式的恢复数据要慢一些。</h2><h2 id="2、如何生成RDB文件"><a href="#2、如何生成RDB文件" class="headerlink" title="2、如何生成RDB文件"></a>2、如何生成RDB文件</h2><p>Redis 提供了两个命令来生成 RDB 文件，分别是 <strong>save</strong> 和 <strong>bgsave</strong>，他们的区别就在于<strong>是否在「主线程」里执行</strong>：</p><p>1）执行save，会由主线程生成rdb文件，写入时间太长就会阻塞主线程。</p><p>2）执行bgsave，由子线程生成</p><p>主子进程通过复制页表操作同一块物理内存。</p><p>通过修改配置文件调整rdb的快照频率</p><h2 id="3、混合持久化："><a href="#3、混合持久化：" class="headerlink" title="3、混合持久化："></a>3、混合持久化：</h2><p>1、使用混合持久化，aof的前半部分是rdb格式的全量数据，后半部分是aof的增量数据。</p><h1 id="五、Redis集群cluster"><a href="#五、Redis集群cluster" class="headerlink" title="五、Redis集群cluster"></a>五、Redis集群cluster</h1><h2 id="1、如何实现高可用？"><a href="#1、如何实现高可用？" class="headerlink" title="1、如何实现高可用？"></a>1、如何实现高可用？</h2><p>所有数据修改只在主服务器进行，然后将最新数据同步给从服务器，保持主从一致。</p><h2 id="2、切片集群模式："><a href="#2、切片集群模式：" class="headerlink" title="2、切片集群模式："></a>2、切片集群模式：</h2><p>数据量太大，需要分布到不同的服务器上。</p><p>一个切片集群有16384个哈希槽slot，对于每一个键值对的key，使用crc16算法计算16bit的值，然后对16384取模。</p><p>将这16384个slot平均或手动分配到redis实例上</p><h2 id="3、集群脑裂"><a href="#3、集群脑裂" class="headerlink" title="3、集群脑裂"></a>3、集群脑裂</h2><h3 id="1）定义"><a href="#1）定义" class="headerlink" title="1）定义"></a>1）定义</h3><p>由于网络问题，主节点与其他从节点失去联系，哨兵会选出新的主节点，网络恢复后原先的主节点会降级为从节点并从新的主节点处拷贝数据，在网络失效的这段时间里，客户端向原先主节点写入的数据就会失效。</p><h3 id="2）解决方式："><a href="#2）解决方式：" class="headerlink" title="2）解决方式："></a>2）解决方式：</h3><p>当主节点发现从节点下线，联系不到，就禁止主节点进行写数据，直接把错误返回客户端。</p><p>min-slaves-to-write x ：至少x个从节点连接</p><p>min-slaves-max-lag  x ：主从节点延时不超过x秒</p><h1 id="六、过期键的处理"><a href="#六、过期键的处理" class="headerlink" title="六、过期键的处理"></a>六、过期键的处理</h1><h2 id="1、惰性删除和定期删除"><a href="#1、惰性删除和定期删除" class="headerlink" title="1、惰性删除和定期删除"></a>1、惰性删除和定期删除</h2><h2 id="2、持久化时对过期键的处理"><a href="#2、持久化时对过期键的处理" class="headerlink" title="2、持久化时对过期键的处理"></a>2、持久化时对过期键的处理</h2><h2 id="3、主从模式下对过期键的处理"><a href="#3、主从模式下对过期键的处理" class="headerlink" title="3、主从模式下对过期键的处理"></a>3、主从模式下对过期键的处理</h2><h1 id="七、内存满了，内存淘汰策略"><a href="#七、内存满了，内存淘汰策略" class="headerlink" title="七、内存满了，内存淘汰策略"></a>七、内存满了，内存淘汰策略</h1><h2 id="1、不进行数据淘汰的策略：noeviction-3-0之后的默认策略"><a href="#1、不进行数据淘汰的策略：noeviction-3-0之后的默认策略" class="headerlink" title="1、不进行数据淘汰的策略：noeviction(3.0之后的默认策略)"></a>1、不进行数据淘汰的策略：noeviction(3.0之后的默认策略)</h2><h2 id="2、进行数据淘汰：七种"><a href="#2、进行数据淘汰：七种" class="headerlink" title="2、进行数据淘汰：七种"></a>2、进行数据淘汰：七种</h2><p>redis自己的lru算法：随机抽五个，淘汰其中最久没被使用的</p><p>lru和lfu都是在redis对象头中定义一个24bit的字段来存储时间戳和访问频率</p><h1 id="八、缓存雪崩，击穿，穿透"><a href="#八、缓存雪崩，击穿，穿透" class="headerlink" title="八、缓存雪崩，击穿，穿透"></a>八、缓存雪崩，击穿，穿透</h1><h2 id="1、雪崩指redis宕机或同时大量的key过期。"><a href="#1、雪崩指redis宕机或同时大量的key过期。" class="headerlink" title="1、雪崩指redis宕机或同时大量的key过期。"></a>1、雪崩指redis宕机或同时大量的key过期。</h2><h2 id="2、击穿指某个热点的key过期。"><a href="#2、击穿指某个热点的key过期。" class="headerlink" title="2、击穿指某个热点的key过期。"></a>2、击穿指某个热点的key过期。</h2><h2 id="3、穿透指查询不存在的数据。"><a href="#3、穿透指查询不存在的数据。" class="headerlink" title="3、穿透指查询不存在的数据。"></a>3、穿透指查询不存在的数据。</h2><h1 id="九、缓存更新策略（当数据库发生修改，需要对缓存进行更新）"><a href="#九、缓存更新策略（当数据库发生修改，需要对缓存进行更新）" class="headerlink" title="九、缓存更新策略（当数据库发生修改，需要对缓存进行更新）"></a>九、缓存更新策略（当数据库发生修改，需要对缓存进行更新）</h1><h2 id="1、Cache-aside策略：黑马讲的策略，先更新数据库，再删除缓存。"><a href="#1、Cache-aside策略：黑马讲的策略，先更新数据库，再删除缓存。" class="headerlink" title="1、Cache aside策略：黑马讲的策略，先更新数据库，再删除缓存。"></a>1、Cache aside策略：黑马讲的策略，先更新数据库，再删除缓存。</h2><h2 id="2、读穿-写穿策略：应用程序只和缓存交互"><a href="#2、读穿-写穿策略：应用程序只和缓存交互" class="headerlink" title="2、读穿&#x2F;写穿策略：应用程序只和缓存交互"></a>2、读穿&#x2F;写穿策略：应用程序只和缓存交互</h2><p>Read through：查询缓存中是否存在，存在则直接返回；不存在，则由缓存负责从数据库查数据，将结果再写入缓存，最后返回给客户端。</p><p>Write through：写入数据时先查询要写入的数据是否已存在，</p><p>若已存在，则更新缓存中的数据，再由缓存更新到数据库中。</p><p>若不存在，则直接更新数据库。</p><p>这种策略一般在使用本地缓存中考虑，因为redis和memcached不支持。</p><h2 id="3、写回策略（write-back）"><a href="#3、写回策略（write-back）" class="headerlink" title="3、写回策略（write back）"></a>3、写回策略（write back）</h2><p>写时只更新缓存，同时将缓存数据设置为脏，然后立马返回。</p><p>对于数据库的更新，使用批量异步更新的方式。</p><p>写回策略也很少用于redis中，因为redis无法异步更新数据库。写回策略主要用在cpu缓存，文件系统缓存。</p><h1 id="十、redis实现延迟队列"><a href="#十、redis实现延迟队列" class="headerlink" title="十、redis实现延迟队列"></a>十、redis实现延迟队列</h1><p>把当前要做的事，推迟一段时间再做</p><p>使用有序队列zset来实现，其中<strong>score</strong>属性（权重）存储延迟执行的时间。</p><p>使用zadd score1 value1 命令往内存中生产消息，再用zrangebysocre查询待处理任务。</p><h1 id="十一、大key如何处理-value很大的key"><a href="#十一、大key如何处理-value很大的key" class="headerlink" title="十一、大key如何处理(value很大的key)"></a>十一、大key如何处理(value很大的key)</h1><h2 id="1、查找大key"><a href="#1、查找大key" class="headerlink" title="1、查找大key"></a>1、查找大key</h2><p>1)通过 redis-cli –bigkeys 命令，并做好在从节点上执行，但只能返回每种类型中最大的bigkey</p><p>2)使用SCAN命令扫描数据库</p><p>3)使用rdbtools第三方开源工具解析redis快照rdb文件，找到大key。</p><h2 id="2、删除内存中的key"><a href="#2、删除内存中的key" class="headerlink" title="2、删除内存中的key"></a>2、删除内存中的key</h2><p>在删除过程中，需要把释放掉的内存块插入空闲内存块的链表，这个过程会消耗一定时间。</p><p>解决方式：</p><p>1、<strong>分批次删</strong>，但还是在主线程中</p><p>2、<strong>异步删除</strong>，用unlink代替del，将key放入一个异步线程中删除。即lazyfree线程。</p><h1 id="十二、redis管道（pipeline）"><a href="#十二、redis管道（pipeline）" class="headerlink" title="十二、redis管道（pipeline）"></a>十二、redis管道（pipeline）</h1><p>客户端提供的批处理技术，一次处理多个 Redis 命令，将多个命令打包一起发送给服务器端。</p><h1 id="十三、redis没有事务运行错误回滚，不支持事务原子性"><a href="#十三、redis没有事务运行错误回滚，不支持事务原子性" class="headerlink" title="十三、redis没有事务运行错误回滚，不支持事务原子性"></a>十三、redis没有事务运行错误回滚，不支持事务原子性</h1><h2 id="1、原因"><a href="#1、原因" class="headerlink" title="1、原因"></a>1、原因</h2><p>因为作者认为<strong>加回滚会损失性能</strong>，而且错误一般是编程错误导致。</p><h2 id="2、解决方式："><a href="#2、解决方式：" class="headerlink" title="2、解决方式："></a>2、解决方式：</h2><p>1）使用lua脚本</p><h1 id="十四、用redis实现分布式锁"><a href="#十四、用redis实现分布式锁" class="headerlink" title="十四、用redis实现分布式锁"></a>十四、用redis实现分布式锁</h1><h2 id="1、set命令的nx参数实现key不存在才插入，可以用它实现分布式锁，"><a href="#1、set命令的nx参数实现key不存在才插入，可以用它实现分布式锁，" class="headerlink" title="1、set命令的nx参数实现key不存在才插入，可以用它实现分布式锁，"></a>1、set命令的nx参数实现key不存在才插入，可以用它实现分布式锁，</h2><p>如果key不存在，则插入成功，表示加锁成功</p><p>如果key存在，则插入失败，表示加锁失败</p><h3 id="1）加解锁指令："><a href="#1）加解锁指令：" class="headerlink" title="1）加解锁指令："></a>1）加解锁指令：</h3><p>SET lock_key unique_value NX PX 10000</p><p>Unique_value标识客户端，PX设置过期时间10s。</p><p>解锁的时候需要先判断执行操作的客户端是否是unique_value对应的客户端。</p><p>解锁时的原子性可以由lua脚本保证，lua脚本在redis执行是保证原子性的。</p><h2 id="2、优缺点"><a href="#2、优缺点" class="headerlink" title="2、优缺点"></a>2、优缺点</h2><p>使用redis实现分布式锁的</p><p>优点：1、性能高，2、实现方便，3、避免单点故障（跨集群部署）</p><p>缺点：1、超时时间不好设置，2、主从复制是异步的，导致分布式锁<strong>不可靠</strong>。</p><h2 id="3、为了保证可靠性，官方设计分布式锁算法redlock红锁"><a href="#3、为了保证可靠性，官方设计分布式锁算法redlock红锁" class="headerlink" title="3、为了保证可靠性，官方设计分布式锁算法redlock红锁"></a>3、为了保证可靠性，官方设计分布式锁算法redlock红锁</h2><p>它是多节点的锁，让客户端和多个独立的redis节点依次请求加锁，若半数以上能成功，就认为加锁成功。</p>]]></content>
    
    
    
    <tags>
      
      <tag>知识分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客</title>
    <link href="/2024/12/10/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/12/10/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h2><p>这是我的第一篇发表在个人博客网站上的博客，我想用它来测试功能，并展示我是如何搭建起博客网站的。</p><h3 id="我搭建网站参考的博客："><a href="#我搭建网站参考的博客：" class="headerlink" title="我搭建网站参考的博客："></a>我搭建网站参考的博客：</h3><p><a href="https://blog.csdn.net/yaorongke/article/details/119089190">GitHub Pages + Hexo搭建个人博客网站，史上最全教程_hexo博客-CSDN博客</a></p><p>其中也碰了壁：</p><p>1、使用leanCloud得用国际版，国内版得备案</p><p>2、图片无法展示</p>]]></content>
    
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
